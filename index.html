<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, addDoc, onSnapshot, collection, query, orderBy, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Variabili configurabili dall'ambiente (se presenti)
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
    const apiKey = ''; // SE HAI LA CHIAVE METTILA QUI
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent${apiKey ? ('?key=' + apiKey) : ''}`;

    // DOM elements (i module script sono defer, quindi OK)
    const chatContainer = document.getElementById('chat-container');
    const chatForm = document.getElementById('chat-form');
    const chatInput = document.getElementById('chat-input');
    const loadingIndicator = document.getElementById('loading-indicator');

    let db = null, auth = null, userId = null;
    let isAuthReady = false;
    let localMessages = []; // fallback se Firebase non c'è

    window.onload = async () => {
        document.getElementById('status').textContent = 'Inizializzazione...';

        if (firebaseConfig) {
            try {
                // setLogLevel('debug');
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Autenticazione: osserva lo stato
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                    } else {
                        try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                                userId = auth.currentUser.uid;
                            } else {
                                await signInAnonymously(auth);
                                userId = auth.currentUser.uid;
                            }
                        } catch (error) {
                            console.error("Errore auth:", error);
                            userId = crypto.randomUUID();
                            document.getElementById('status').textContent = 'Autenticazione fallita (ID temporaneo)';
                            document.getElementById('status').classList.add('text-red-500');
                        }
                    }

                    document.getElementById('user-id-display').textContent = `ID Utente: ${userId}`;
                    isAuthReady = true;

                    if (userId && db) {
                        setupChatListener();
                        enableChatUI();
                    }
                });
            } catch (err) {
                console.error("Errore init Firebase:", err);
                // fallback locale
                firebaseFallback();
            }
        } else {
            // Fallback locale se manca la configurazione Firebase
            console.warn("Firebase config mancante - avvio in modalità locale");
            firebaseFallback();
        }
    };

    function firebaseFallback() {
        // crea un userId temporaneo e abilita la UI locale
        userId = `local-${crypto.randomUUID()}`;
        document.getElementById('user-id-display').textContent = `ID Utente: ${userId}`;
        isAuthReady = true;
        enableChatUI();
        // carica eventuali messaggi locali già presenti
        renderLocalMessages();
    }

    function enableChatUI() {
        const form = document.getElementById('chat-form');
        form.classList.remove('opacity-50', 'pointer-events-none');
        document.getElementById('loading-init').classList.add('hidden');
        document.getElementById('status').textContent = 'Pronto';
    }

    // --- AI System Instruction (lasciata come prima) ---
    const AI_SYSTEM_INSTRUCTION = `Sei l'AI-Rft (Risonanza Fratao), ...`; // abbrevia qui come nel file originale

    // Utility: aggiunge messaggio in Firestore se db esiste, altrimenti salva localmente
    async function addMessageToFirestore(role, text) {
        if (db) {
            try {
                const chatCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/messages`);
                await addDoc(chatCollectionRef, {
                    role: role,
                    text: text,
                    timestamp: new Date()
                });
            } catch (e) {
                console.error("Errore nell'aggiunta al Firestore:", e);
                displayError("Impossibile salvare il messaggio su Firestore.");
            }
        } else {
            // fallback locale: salva nell'array e renderizza subito
            localMessages.push({ role, text, timestamp: new Date() });
            appendMessageToUI({ role, text });
        }
    }

    function formatChatHistory(messages) {
        return messages.map(msg => ({
            role: msg.role === 'user' ? 'user' : 'model',
            parts: [{ text: msg.text }]
        }));
    }

    // Chiamata API: se manca apiKey, restituisce risposta finta (placeholder)
    async function callGeminiApi(history, messageText, retries = 0) {
        if (!apiKey) {
            // risposta di fallback rapida per test locale
            return `Risposta di test (modalità offline). Hai chiesto: "${messageText}"`;
        }

        const maxRetries = 5;
        const delay = Math.pow(2, retries) * 1000;

        const contents = [
            ...history,
            { role: 'user', parts: [{ text: messageText }] }
        ];

        const payload = {
            contents: contents,
            tools: [{ "google_search": {} }],
            systemInstruction: { parts: [{ text: AI_SYSTEM_INSTRUCTION }] },
        };

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                if (response.status === 429 && retries < maxRetries) {
                    await new Promise(r => setTimeout(r, delay));
                    return callGeminiApi(history, messageText, retries + 1);
                }
                throw new Error(`API Error: ${response.status} ${response.statusText}`);
            }

            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) throw new Error("Risposta API vuota");
            return text;
        } catch (err) {
            console.error("Errore API Gemini:", err);
            throw new Error("Errore comunicazione AI.");
        }
    }

    // Gestore invio messaggi
    chatForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const messageText = chatInput.value.trim();
        if (!messageText || !isAuthReady) return;

        chatInput.value = '';
        await addMessageToFirestore('user', messageText);

        loadingIndicator.classList.remove('hidden');
        chatInput.disabled = true;

        try {
            // costruisci cronologia da UI (locale + firestore fallback)
            const chatMessages = Array.from(chatContainer.querySelectorAll('.message-item'))
                .map(el => ({
                    role: el.dataset.role,
                    text: el.querySelector('p').textContent.trim()
                }))
                .filter(m => m.role);

            const history = formatChatHistory(chatMessages);
            const aiResponseText = await callGeminiApi(history, messageText);

            await addMessageToFirestore('model', aiResponseText);
        } catch (error) {
            displayError(error.message || 'Errore durante la richiesta AI.');
        } finally {
            loadingIndicator.classList.add('hidden');
            chatInput.disabled = false;
            chatInput.focus();
        }
    });

    // UI helpers
    function displayError(message) {
        const errorElement = document.createElement('div');
        errorElement.className = 'p-3 my-2 text-sm font-medium text-red-800 bg-red-100 rounded-lg shadow-md';
        errorElement.textContent = `Errore: ${message}`;
        chatContainer.appendChild(errorElement);
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function createMessageElement(message) {
        const div = document.createElement('div');
        const roleClass = message.role === 'user' ? 'justify-end' : 'justify-start';
        const bubbleClass = message.role === 'user' ? 'user-message text-gray-800 rounded-br-none ml-auto' : 'ai-message text-gray-800 rounded-tl-none mr-auto';

        div.className = `flex ${roleClass} mb-4 max-w-full`;
        div.dataset.role = message.role;
        div.classList.add('message-item');

        div.innerHTML = `
            <div class="max-w-3/4 p-4 rounded-xl shadow-lg ${bubbleClass} whitespace-pre-wrap">
                <p>${escapeHtml(message.text)}</p>
            </div>
        `;
        return div;
    }

    function appendMessageToUI(message) {
        chatContainer.appendChild(createMessageElement(message));
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // Rendere e caricare i messaggi locali all'avvio fallback
    function renderLocalMessages() {
        chatContainer.innerHTML = '';
        localMessages.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp))
                     .forEach(m => appendMessageToUI(m));
    }

    // Funzione di ascolto Firestore (solo se db è presente)
    function setupChatListener() {
        if (!db) return;
        const chatCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/messages`);
        const q = query(chatCollectionRef, orderBy('timestamp'));

        onSnapshot(q, (snapshot) => {
            const allMessages = snapshot.docs.map(doc => ({ ...doc.data(), id: doc.id }));
            allMessages.sort((a,b) => a.timestamp.toDate() - b.timestamp.toDate());
            chatContainer.innerHTML = '';
            allMessages.forEach(msg => appendMessageToUI(msg));
        }, (error) => {
            console.error("Errore onSnapshot:", error);
            displayError("Impossibile caricare la cronologia in tempo reale.");
        });
    }

    // semplice escape per evitare HTML injection nei test locali
    function escapeHtml(unsafe) {
        return unsafe
            .replaceAll('&', "&amp;")
            .replaceAll('<', "&lt;")
            .replaceAll('>', "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
    }
</script>